# MUSES: Multi-source ensemble of secondary structures
# Heqin Zhu
# zhuheqin1@gmail.com

import os
import argparse
from itertools import product

import numpy as np
import pandas as pd

from BPfold.util.misc import get_file_name
from BPfold.util.base_pair_probability import read_BPP_from_ps, read_BPPM
from BPfold.util.RNA_kit import read_SS, dbn2connects, connects2mat, mat2connects, connects2dbn, cal_metric, read_fasta


def average_matrices(matrices, weights=None):
    # matrices: list of dicts or 2D lists with keys (i,j) or size n x n with j>i
    M = len(matrices)
    if M!=0:
        n = len(matrices[0])
        assert len(matrices[0][0]) == n
        for i in range(1, M):
            assert len(matrices[i][0]) == len(matrices[i]) == n
    if weights is None:
        weights = [1.0]*M
    # assume matrices are n x n lists
    n = len(matrices[0])
    P = [[0.0]*n for _ in range(n)]
    wsum = sum(weights)
    for m, mat in enumerate(matrices):
        w = weights[m]
        for i in range(n):
            for j in range(i+1, n):
                P[i][j] += w * mat[i][j]
    for i in range(n):
        for j in range(i+1, n):
            P[i][j] /= wsum
    return P


def mea_decode(P, gamma=1.0, min_loop_length=3):
    # MEA-style ensemble decoder (non-crossing)
    # P: n x n upper-triangular with probabilities; gamma balances pairs vs unpaired
    # returns list of pairs (i,j)
    n = len(P)
    # score for pairing i,j can be (2*P - 1) or simply P; MEA often uses 2P - 1 with gamma scaling
    # We'll use s = gamma * P[i][j]
    dp = [[0.0]*n for _ in range(n)]
    bt = [[None]*n for _ in range(n)]
    for l in range(min_loop_length+1, n):  # length of subseq
        for i in range(0, n-l):
            j = i + l
            # case 1: i unpaired
            best = dp[i+1][j]
            bt_choice = ('unpair_i', None)
            # case 2: j unpaired
            if dp[i][j-1] > best:
                best = dp[i][j-1]
                bt_choice = ('unpair_j', None)
            # case 3: i paired with k (i<k<=j)
            # two options: directly pair i and j
            if j - i - 1 >= min_loop_length:
                s = gamma * P[i][j] + (dp[i+1][j-1] if i+1<=j-1 else 0.0)
                if s > best:
                    best = s
                    bt_choice = ('pair', j)
            # or split at k
            for k in range(i+1, j):
                s = dp[i][k] + dp[k+1][j]
                if s > best:
                    best = s
                    bt_choice = ('split', k)
            dp[i][j] = best
            bt[i][j] = bt_choice
    # traceback
    pairs = []
    def traceback(i,j):
        if i>=j:
            return
        choice = bt[i][j]
        if choice is None:
            return
        typ, val = choice
        if typ == 'unpair_i':
            traceback(i+1, j)
        elif typ == 'unpair_j':
            traceback(i, j-1)
        elif typ == 'pair':
            k = val
            pairs.append((i, k))
            traceback(i+1, k-1)
            traceback(k+1, j)
        elif typ == 'split':
            k = val
            traceback(i, k)
            traceback(k+1, j)
    traceback(0, n-1)
    return pairs


def pairs_to_dotbracket(pairs, n):
    s = ['.']*n
    for i,j in pairs:
        s[i] = '('
        s[j] = ')'
    return ''.join(s)


def read_BPP_from_MXfold2(path):
    '''
        read BPPM generated by MXfold2
    '''
    with open(path) as f:
        f.readline()
        lines = [line.strip('\n\r ') for line in f.readlines()]
    L = len(lines)
    ret = np.zeros((L, L), dtype=np.float32)
    for i, line in enumerate(lines):
        for j, part in enumerate(line.split(' ')[1:]):
            if j>=i:
                break
            val = float(part)
            if val>0:
                ret[i, j] = ret[j, i] = val
    return ret


def read_mat_of_method(method_name, ss_path):
    if any([ss_path.lower().endswith(suf) for suf in ['bpseq', 'ct', 'dbn']]):
        # BPfold, SPOT-RNA
        seq, connects = read_SS(ss_path)
        return connects2mat(connects)
    elif method_name.lower() == 'mxfold2':
        return read_BPP_from_MXfold2(ss_path)
    elif method_name.lower() in ['rnafold', 'viennarna'] or any([ss_path.lower().endswith(suf) for suf in ['ps']]):
        return read_BPP_from_ps(ss_path)[1]
    elif method_name.lower() == 'contrafold':
        return read_BPPM(ss_path)
    elif method_name.lower() == 'linearfold':
        raise NotImplementedError
    else:
        print(f'[Warning]: Unknown method name, ignored: {method_name}')


def MUSES(mats, weights=None):
    P = average_matrices(mats, weights)
    pairs = mea_decode(P, gamma=1.0)
    n = len(mats[0])
    dot = pairs_to_dotbracket(pairs, n)
    return dot


def MUSES_from_files(method_names, ss_paths, weights=None):
    assert len(method_names) == len(ss_paths)
    ## soft for BPfold, 0.9, 0.1
    mats = []
    for method_name, ss_path in zip(method_names, ss_paths):
        mat = read_mat_of_method(method_name, ss_path)
        if mat is not None:
            mats.append(mat)
    return MUSES(mats, weights)


def get_ss_path_of_method(method, dataset, name):
    dir_name_mapping = {
                        'BPfold': lambda name: os.path.join('BPfold_test_results', dataset, name+'.bpseq'),
                        'SPOT-RNA': lambda name: os.path.join('SPOT-RNA_results', dataset, name+'.bpseq'),
                        'MXfold2': lambda name: os.path.join('MXfold2_bpp', dataset, name+'.bpp'),
                        'RNAfold': lambda name: os.path.join('ViennaRNA_ps', dataset, name+'_dp.ps'),
                        'ViennaRNA': lambda name: os.path.join('ViennaRNA_ps', dataset, name+'_dp.ps'),
                        'CONTRAfold': lambda name: os.path.join('contrafold_ps', dataset, name+'.bpp'),
                       }
    return dir_name_mapping[method](name)


def get_all_bpp(data_dir, gt_dir, datasets, method_names, VERBOSE=False, METRIC='INF'):
    METRIC='INF'
    all_data = {}
    for dataset in datasets:
        all_data[dataset] = {}
        gt_dataset_dir = os.path.join(gt_dir, dataset)
        name_seq_ss = {get_file_name(f): read_SS(os.path.join(gt_dataset_dir, f)) for f in os.listdir(gt_dataset_dir)}
        names = {name for name, seq in read_fasta(f'/public2/home/heqinzhu/gitrepo/RNA/SS_pred/mydata/missing_MUSES/{dataset}.fasta')}
        name_seq_ss = {k: v for k, v in name_seq_ss.items() if k in names}
        for name, (seq, gt_connects) in name_seq_ss.items():
            all_data[dataset][name] = {}
            # gt
            if VERBOSE:
                print(name)
                print(seq)
                print(connects2dbn(gt_connects), 'gt')
            gt_mat = connects2mat(gt_connects)
            all_data[dataset][name]['gt'] = gt_mat
            all_data[dataset][name]['seq'] = seq
            # pred methods
            ss_paths = [os.path.join(data_dir, get_ss_path_of_method(method_name, dataset, name)) for method_name in method_names]
            for method_name, ss_path in zip(method_names, ss_paths):
                pred_mat = read_mat_of_method(method_name, ss_path)
                all_data[dataset][name][method_name] = pred_mat
                if VERBOSE:
                    pred_metric_mat = connects2mat(mat2connects(pred_mat)) # convert bpp to 0-1 contact map
                    metric_dic = cal_metric(pred_metric_mat, gt_mat)
                    print(connects2dbn(mat2connects(pred_mat)), method_name, metric_dic[METRIC])
            if VERBOSE:
                # MUSES
                muses_dbn = MUSES_from_files(method_names, ss_paths)
                muses_mat = connects2mat(dbn2connects(muses_dbn))
                print(muses_dbn, 'MUSES', cal_metric(muses_mat, gt_mat)[METRIC])
    return all_data


def MUSES_weights_grid_search(dest_dir, all_bpp, method_names, weights):
    if sum(weights)==0:
        raise Exception(f'weights are all zero')
    os.makedirs(dest_dir, exist_ok=True)
    MUSES_name = 'MUSES_' + '_'.join([f'{int(w):d}.{method_name}' for method_name, w in zip(method_names, weights)])
    df_data = []
    for dataset, dataset_dic in all_bpp.items():
        for name, mat_dic in dataset_dic.items():
            base_dic = {
                        'name': name,
                        'dataset': dataset,
                        'seq': mat_dic['seq'],
                       }
            mats = []
            cur_dic = {}
            for i, method_name in enumerate(method_names):
                mats.append(mat_dic[method_name])
                cur_dic[f'w_{method_name}'] = weights[i]

            muses_dbn = MUSES(mats, weights)
            muses_mat = connects2mat(dbn2connects(muses_dbn))
            cur_dic.update(cal_metric(muses_mat, mat_dic['gt']))
            cur_dic['method'] = MUSES_name
            cur_dic.update(base_dic)

            df_data.append(cur_dic)
    df = pd.DataFrame(df_data)
    df.to_csv(os.path.join(dest_dir, MUSES_name+'.csv'), index=False)


def get_method_bpp(dest_dir, all_bpp, method_names):
    df_data = []
    for dataset, dataset_dic in all_bpp.items():
        for name, mat_dic in dataset_dic.items():
            base_dic = {
                        'name': name,
                        'dataset': dataset,
                        'seq': mat_dic['seq'],
                       }
            mats = []
            for i, method_name in enumerate(method_names):
                pred_bpp = mat_dic[method_name]
                mats.append(pred_bpp)

                pred_contact = connects2mat(mat2connects(pred_bpp)) # convert bpp to 0-1 contact map
                cur_dic = cal_metric(pred_contact, mat_dic['gt'])
                cur_dic['method'] = method_name
                for cur_method in method_names:
                    if cur_method == method_name:
                        cur_dic[f'w_{cur_method}'] = 1
                    else:
                        cur_dic[f'w_{cur_method}'] = 0
                cur_dic.update(base_dic)
                df_data.append(cur_dic)
    df = pd.DataFrame(df_data)
    df.to_csv(os.path.join(dest_dir, 'single_mehtod.csv'), index=False)


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--dest_dir', type=str, default='MUSES_weights')
    parser.add_argument('--data_dir', type=str, default='/public2/home/heqinzhu/gitrepo/RNA/SS_pred/BPfold/test_data_SS')
    parser.add_argument('--gt_dir', type=str, default='/public2/home/heqinzhu/gitrepo/RNA/SS_pred/mydata/test_data')
    parser.add_argument('--datasets', nargs='+', default=['PDB_test', 'Rfam12.3-14.10', 'archiveII'])
    parser.add_argument('--method_names', nargs='+', default=['BPfold', 'RNAfold', 'CONTRAfold'])
    parser.add_argument('--weights', nargs='+', default=None)
    parser.add_argument('--weight_range', nargs='+', default=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    return parser.parse_args()


if __name__ == "__main__":
    args = get_args()
    if args.weights is None:
        args.weights = [1]*len(args.method_names)


    args.dest_dir = 'missing_MUSES_weights' 
    args.datasets = ['Rfam12.3-14.10', 'archiveII']

        
    all_bpp = get_all_bpp(args.data_dir, args.gt_dir, args.datasets, args.method_names, VERBOSE=False)
    for weights in product(*[args.weight_range for _ in args.method_names]):
        if sum(weights)!=0:
            MUSES_weights_grid_search(args.dest_dir, all_bpp, args.method_names, weights)
    # MUSES_weights_grid_search(args.dest_dir, all_bpp, args.method_names, weights=[float(i) for i in args.weights])
